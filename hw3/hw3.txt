HW3: Due 11:59PM August 14th

1. What design principles did you use in assignment 3? Discuss.

We have used the below principles:

SRP: We have three test classes FibonacciIterativeTest, FibonacciMemoizedTest,and FibonacciRecursiveTest. Each of these test classes is only responsible for testing a particular implementation of the Fibonacci computation.

DRY: The test classes share the same set of tests, but have different ways of computing a Fibonacci number given the position of that number. In order to comply with DRY principle, the tests are brought into an abstract class FibonacciNumbersTest. Each test function will then call the function callFibonacci() to compute a Fibonacci number. The function callFibonacci()is an abstract method of the FibonacciNumbersTest class, and is implemented specifically in each test class.


2. What design patterns did you use in assignment 3? Discuss.

We have used the below design patterns:

Cascade Method Pattern: in the functions fibonacciIterative() and fibonacciMemoized, we have used the cascade method pattern to perform computations on the collection objects instead of using loops. 

return IntStream.rangeClosed(2, n)
                .mapToObj(i -> Pair.of(i, 0))
                .reduce(fiboPair, (prev, ignore) ->    Pair.of(prev.getRight(), prev.getLeft() + prev.getRight()))
                .getRight();

The loop version:

for(int i = 2; i <= n; i++)
{
	int left = fiboPair.getLeft();
	fiboPair = Pair.of(fiboPair.getRight(), left +   fiboPair.getRight());
} 

return fiboPair.getRight());

The method cascading syntax looks complex for those who are unfamiliar with syntax. However it is worth being used because it makes the code look nicer and more elegant than the loop version.

Iterator Pattern: As we can see in the cascading method pattern above, the iterator pattern also takes part in. The syntax provides a way to traverse the collection object to do computation without exposing the collection object’s internal structure.

Factory Method Pattern: We have abstract class FibonacciNumbersTest defining the set of test which is extended by FibonacciMemoizedTest, FibonacciIterativeTest, FibonacciRecursiveTest. Those three class have same callFibonacci method, but have different ways to get the  fibonacci number of n.  


3. What design principles did you use in assignment 4? Discuss.

The design principles used are:

OCP: Player class depends on the form classes to perform actions.
By introducing the Avatar interface which will be implemented by each form class, we have more flexibility to add new form classes later on without changing the Player class. 

In addition, we have the FormSequence class which can read an input file to build a form sequence for the Player class. This helps to us to change the transformation rules easily without modifying the existing codes. All we need to do is to update the input file and restart the application.

SRP: Each form class implements the Avatar interface and only performs exactly one action according to their specific form at run-time.

DIP: The Player class depends on the form class to perform actions. Instead of being dependent on each specific form class, the Player class is designed to depend on the Avatar interface only. The Avatar interface is implemented by each specific form class.

The Player does not worry about how an avatar will perform an action. It only knows that it can receive an avatar, and the action performing job is let up to that avatar at run-time.

DRY: In FormSequenceTest class, the tests of create Avatar List with valid and invalid name list have same way to test, just different name list. To avoid duplication, we create compareTwoListsOfAvatar() method to compare two lists of avatar.

LSP: We have the Avatar interface class defining an action which is implemented by different type of Avatar such as Bike, Car, Plane and Rocket. We want to make sure that new derived classes are extending the base classes without changing their behavior.

4. What design patterns did you use in assignment 4? Discuss.

We have used the below design patterns:

- Cascade Method Pattern: In createAvatarList, inputFromFile methods of FormSequence class, we have use we have used the cascade method pattern to make the code look better, easier to understand.
public List<Avatar> createAvatarList(List<String> nameList)
    {
        return nameList.stream().map(item -> createAvatar(item)).collect(Collectors.toList());        
    }

- Iterator Pattern: We use the List of Avatars in our code as you see above, we use interator pattern to access the elements of a collection object in sequential manner without exposing its internal structure. 

- Strategy Pattern: We have the Avatar interface class defining an action which is implemented by different type of Avatar such as Bike, Car, Plane and Rocket. Player is a class which uses a Avatar. This is an idea to isolate the action in separate classes in order to have the ability to select different action at runtime.

- Singleton Pattern: In FromSequence class, we used singleton pattern in createAvatar() method to return the specific type of Avatar.
public Avatar createAvatar(String avatarName)
    {
        try {
            return Class.forName("assignment4." + avatarName).asSubclass(Avatar.class).newInstance();
        } catch(Exception e) {
            return null;
        }  
    }

- Factory Method Pattern: In the code above, we also use factory method pattern to create different avatars with given name. It defines an interface for creating an object, but leaves the choice of its type to the subclasses.
//Venkat: This is not quite factory method, reexamine. Discuss how it's used, that may help you see what pattern this is.